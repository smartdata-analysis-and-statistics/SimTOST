# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Compute p-values with Fixed Degrees of Freedom
#'
#' @description
#' Computes the cumulative distribution function (CDF) values (p-values)
#' for a given set of random variables, assuming a t-distribution with fixed
#' degrees of freedom.
#'
#' @param x A numeric matrix (or vector) of random variables.
#' @param df A double specifying the degrees of freedom.
#' @param lower A boolean indicating whether to calculate the lower-tail probability
#' (i.e., P(T <= x)). If `false`, computes the upper-tail probability (P(T > x)).
#'
#' @return A numeric matrix containing the computed CDF values (p-values).
#' @export
ptv <- function(x, df, lower) {
    .Call(`_SimTOST_ptv`, x, df, lower)
}

#' @title Calculate p-values using t-distribution with Variable Degrees of Freedom
#'
#' @description This function computes the cumulative distribution function (p-values) for a given random variable `x`
#' and corresponding degrees of freedom `df` using the t-distribution. The function can compute the lower or upper
#' tail probabilities depending on the value of the `lower` parameter.
#'
#' @param x arma::mat (vector) - A matrix or vector of random variable values for which the p-values will be calculated.
#' @param df arma::mat (vector) - A matrix or vector of degrees of freedom for the t-distribution, matching the size of `x`.
#' @param lower bool - If `TRUE`, calculates the lower-tail probability (P(T <= x)); if `FALSE`, calculates the upper-tail probability.
#' @return arma::mat (vector) - A matrix containing the computed cumulative distribution function (p-values) for each element in `x`.
#' The result is returned as a 1xN matrix, where N is the number of elements in `x`.
#' @export
ptvdf <- function(x, df, lower) {
    .Call(`_SimTOST_ptvdf`, x, df, lower)
}

#' @title Check Equivalence for Multiple Endpoints
#'
#' @description
#' This function evaluates whether equivalence criteria are met based on a predefined set of endpoints.
#' It first checks whether all primary endpoints satisfy equivalence (if sequential testing is enabled).
#' Then, it determines whether the required number of endpoints (`k`) meet the equivalence threshold.
#' The function returns a binary matrix indicating whether equivalence is established.
#'
#' @param typey An unsigned integer vector (`arma::uvec`) indicating the type of each endpoint:
#'              - `1` = Primary endpoint
#'              - `2` = Secondary endpoint
#' @param adseq A boolean flag (`TRUE` if sequential testing is enabled).
#'              - If `TRUE`, all primary endpoints must pass equivalence for secondary endpoints to be evaluated.
#'              - If `FALSE`, primary and secondary endpoints are evaluated independently.
#' @param tbioq A matrix (`arma::mat`) containing the equivalence test results for each endpoint:
#'              - `1` = Equivalence met
#'              - `0` = Equivalence not met
#' @param k An integer specifying the minimum number of endpoints required to establish equivalence.
#'
#' @details
#' - **Sequential Adjustment (`adseq = TRUE`)**:
#'   - Ensures that all primary endpoints must meet equivalence before secondary endpoints are evaluated.
#' - **Non-Sequential Testing (`adseq = FALSE`)**:
#'   - Evaluates all endpoints simultaneously without enforcing hierarchical constraints.
#' - **Final Equivalence Decision (`totaly`)**:
#'   - `1` if at least `k` endpoints meet equivalence and (if sequential testing is enabled) all primary endpoints pass.
#'   - `0` otherwise.
#'
#' @return
#' An `arma::mat` (1 × 1 matrix) containing a binary equivalence decision:
#' - `1` = Equivalence established.
#' - `0` = Equivalence not established.
#'
#' @author Thomas Debray \email{tdebray@fromdatatowisdom.com}
#' @export
check_equivalence <- function(typey, adseq, tbioq, k) {
    .Call(`_SimTOST_check_equivalence`, typey, adseq, tbioq, k)
}

#' @title Simulate a 2x2 Crossover Design and Compute Difference of Means (DOM)
#'
#' @description
#' Simulates a 2x2 crossover design and calculates the p-value for the
#' difference of means (DOM) using a two-sequence, two-period (2x2) study design.
#'
#' @param n integer number of subjects per sequence
#' @param muT vector mean of endpoints on treatment arm
#' @param muR vector mean of endpoints on reference arm
#' @param SigmaW matrix  within subject covar-variance matrix across endpoints
#' @param lequi_tol vector  lower equivalence tolerance band across endpoints
#' @param uequi_tol vector  upper equivalence tolerance band across endpoints
#' @param alpha vector alpha value across endpoints
#' @param sigmaB double between subject variance (assumed same for all endpoints)
#' @param dropout vector of size 2 with dropout proportion per sequence (0,1)
#' @param Eper vector of size 2 with period effect on period (0,1)
#' @param Eco vector of size 2 with carry over effect of arm c(Reference, Treatment).
#' @param typey vector with positions of primary endpoints
#' @param adseq boolean is used a sequential adjustment?
#' @param k integer minimum number of equivalent endpoints
#' @param arm_seed seed for the simulation
#' @return mat(vector) with ptost and other simulated statistics such as mean (mu) and standard deviation(std) per sequence (0,1)-endpoint
#' @export
test_2x2_dom <- function(n, muT, muR, SigmaW, lequi_tol, uequi_tol, alpha, sigmaB, dropout, Eper, Eco, typey, adseq, k, arm_seed) {
    .Call(`_SimTOST_test_2x2_dom`, n, muT, muR, SigmaW, lequi_tol, uequi_tol, alpha, sigmaB, dropout, Eper, Eco, typey, adseq, k, arm_seed)
}

#' @title Simulate a 2x2 Crossover Design and Compute Ratio of Means (ROM)
#'
#' @description
#' Simulates a 2x2 crossover design and calculates the p-value for the
#' ratio of means (ROM) using a two-sequence, two-period (2x2) study design.
#'
#' @param n integer number of subjects per sequence
#' @param muT vector mean of endpoints on treatment arm
#' @param muR vector mean of endpoints on reference arm
#' @param SigmaW matrix  within subject covar-variance matrix across endpoints
#' @param lequi_tol vector  lower equivalence tolerance band across endpoints
#' @param uequi_tol vector  upper equivalence tolerance band across endpoints
#' @param alpha vector alpha value across endpoints
#' @param sigmaB double between subject variance (assumed same for all endpoints)
#' @param dropout vector of size 2 with dropout proportion per sequence (0,1)
#' @param Eper vector of size 2 with period effect on period (0,1)
#' @param Eco vector of size 2 with carry over effect of arm c(Reference, Treatment).
#' @param typey vector with positions of primary endpoints
#' @param adseq boolean is used a sequential adjustment?
#' @param k integer minimum number of equivalent endpoints
#' @param arm_seed seed for the simulation
#' @return mat(vector) with ptost and other simulated statistics such as mean (mu) and standard deviation(std) per sequence (0,1)-endpoint
#' @export
test_2x2_rom <- function(n, muT, muR, SigmaW, lequi_tol, uequi_tol, alpha, sigmaB, dropout, Eper, Eco, typey, adseq, k, arm_seed) {
    .Call(`_SimTOST_test_2x2_rom`, n, muT, muR, SigmaW, lequi_tol, uequi_tol, alpha, sigmaB, dropout, Eper, Eco, typey, adseq, k, arm_seed)
}

#' @title Simulate a Parallel Design and Compute Difference of Means (DOM)
#'
#' @description
#' Simulates a parallel-group design and calculates the p-value for the
#' difference of means (DOM) using an equivalence test.
#'
#' @param n integer number of subjects per arm
#' @param muT vector mean of endpoints on treatment arm
#' @param muR vector mean of endpoints on reference arm
#' @param SigmaT matrix covar-variance matrix on treatment arm across endpoints
#' @param SigmaR matrix covar-variance matrix on reference arm across endpoints
#' @param lequi_tol vector  lower equivalence tolerance band across endpoints
#' @param uequi_tol vector  upper equivalence tolerance band across endpoints
#' @param alpha vector alpha value across endpoints
#' @param dropout vector of size 2 with dropout proportion per arm (T,R)
#' @param typey vector with positions of primary endpoints
#' @param adseq  boolean is used a sequential adjustment?
#' @param k integer minimum number of equivalent endpoints
#' @param arm_seedT integer seed for the simulation on treatment arm
#' @param arm_seedR integer seed for the simulation on reference arm
#' @param TART double treatment allocation rate for the treatment arm
#' @param TARR double treatment allocation rate for the reference arm
#' @param vareq boolean assumed equivalence variance between arms for the t-test
#'
#' @return A numeric matrix containing the following simulated statistics:
#'   - `ptost`: p-values for equivalence testing.
#'   - `mu0`, `mu1`: Mean values for the reference and treatment groups.
#'   - `sd0`, `sd1`: Standard deviations for the reference and treatment groups.
#'   - `totaly`: Indicator (1/0) for equivalence success.
#'
#' @details
#' - The function simulates a parallel-group study design and applies an equivalence test
#'   using the difference of means (DOM) approach.
#' - Adjusts for dropout rates (`dropout`) and treatment allocation rates (`TART`, `TARR`).
#' - Computes test statistics and determines whether the number of significant endpoints meets `k`.
#' - Uses sequential testing if `adseq = TRUE`.
#' - If `vareq = TRUE`, assumes equal variance between treatment and reference groups,
#'   applying Schuirmann’s two one-sided tests (TOST) for equivalence.
#'
#' @export
test_par_dom <- function(n, muT, muR, SigmaT, SigmaR, lequi_tol, uequi_tol, alpha, dropout, typey, adseq, k, arm_seedT, arm_seedR, TART, TARR, vareq) {
    .Call(`_SimTOST_test_par_dom`, n, muT, muR, SigmaT, SigmaR, lequi_tol, uequi_tol, alpha, dropout, typey, adseq, k, arm_seedT, arm_seedR, TART, TARR, vareq)
}

#' @title Simulate a Parallel Design and Compute Ratio of Means (ROM)
#'
#' @description
#' Simulates a parallel-group design and calculates the p-value for the
#' ratio of means (ROM) using an equivalence test.
#'
#' @param n integer number of subjects per arm
#' @param muT vector mean of endpoints on treatment arm
#' @param muR vector mean of endpoints on reference arm
#' @param SigmaT matrix covar-variance matrix on treatment arm across endpoints
#' @param SigmaR matrix covar-variance matrix on reference arm across endpoints
#' @param lequi_tol vector  lower equivalence tolerance band across endpoints
#' @param uequi_tol vector  upper equivalence tolerance band across endpoints
#' @param alpha vector alpha value across endpoints
#' @param dropout vector of size 2 with dropout proportion per arm (T,R)
#' @param typey vector with positions of primary endpoints
#' @param adseq boolean is used a sequential adjustment?
#' @param k integer minimum number of equivalent endpoints
#' @param arm_seedT integer seed for the simulation on treatment arm
#' @param arm_seedR integer seed for the simulation on reference arm
#' @param TART double treatment allocation rate for the treatment arm
#' @param TARR double treatment allocation rate for the reference arm
#' @param vareq Boolean. If `TRUE`, assumes equal variance between arms and applies
#'   Schuirmann’s two one-sided tests (TOST) for equivalence using a pooled variance.
#'
#' @return A numeric matrix containing the following simulated statistics:
#'   - `ptost`: p-values for equivalence testing.
#'   - `mu0`, `mu1`: Mean values for the reference and treatment groups.
#'   - `sd0`, `sd1`: Standard deviations for the reference and treatment groups.
#'   - `totaly`: Indicator (1/0) for equivalence success.
#'
#' @details
#' - The function simulates a parallel-group study design and applies an equivalence test
#'   using the ratio of means (ROM) approach.
#' - Adjusts for dropout rates (`dropout`) and treatment allocation rates (`TART`, `TARR`).
#' - Computes test statistics and determines whether the number of significant endpoints meets `k`.
#' - Uses sequential testing if `adseq = TRUE`.
#' - If `vareq = TRUE`, assumes equal variance between treatment and reference groups,
#'   applying Schuirmann’s two one-sided tests (TOST) for equivalence.
#' @export
test_par_rom <- function(n, muT, muR, SigmaT, SigmaR, lequi_tol, uequi_tol, alpha, dropout, typey, adseq, k, arm_seedT, arm_seedR, TART, TARR, vareq) {
    .Call(`_SimTOST_test_par_rom`, n, muT, muR, SigmaT, SigmaR, lequi_tol, uequi_tol, alpha, dropout, typey, adseq, k, arm_seedT, arm_seedR, TART, TARR, vareq)
}

#' @title Run Simulations for a Parallel Design
#'
#' @description
#' This function simulates a parallel-group trial across multiple iterations (nsim).
#' It evaluates equivalence testing for multiple endpoints using either the
#' Difference of Means (DOM) or Ratio of Means (ROM) approach.
#'
#' @param nsim Integer. The number of simulations to run.
#' @param n Integer. The sample size per arm (before dropout).
#' @param muT arma::vec. Mean vector for the treatment arm.
#' @param muR arma::vec. Mean vector for the reference arm.
#' @param SigmaT arma::mat. Covariance matrix for the treatment arm.
#' @param SigmaR arma::mat. Covariance matrix for the reference arm.
#' @param lequi_tol arma::rowvec. Lower equivalence thresholds for each endpoint.
#' @param uequi_tol arma::rowvec. Upper equivalence thresholds for each endpoint.
#' @param alpha arma::rowvec. Significance level (α) for each endpoint.
#' @param dropout arma::vec. Dropout rates for each arm (T, R).
#' @param typey arma::uvec. Endpoint classification: `1` = primary, `2` = secondary.
#' @param adseq Boolean. If `TRUE`, applies sequential (hierarchical) testing.
#' @param k Integer. Minimum number of endpoints required for equivalence.
#' @param arm_seed_T arma::ivec. Random seed vector for the treatment group (one per simulation).
#' @param arm_seed_R arma::ivec. Random seed vector for the reference group (one per simulation).
#' @param ctype String. Testing method (`"DOM"` for Difference of Means, `"ROM"` for Ratio of Means).
#' @param lognorm Boolean. If `TRUE`, assumes log-normal distribution for endpoints.
#' @param TART Double. Treatment allocation ratio (proportion of subjects in treatment arm).
#' @param TARR Double. Reference allocation ratio (proportion of subjects in reference arm).
#' @param vareq Boolean. If `TRUE`, assumes equal variances across treatment and reference groups.
#'
#' @details
#' - **Equivalence Testing**:
#'   - Uses either Difference of Means (DOM) or Ratio of Means (ROM).
#'   - Applies equivalence thresholds (`lequi_tol`, `uequi_tol`) and significance level (`alpha`).
#' - **Hierarchical Testing (`adseq`)**:
#'   - If `TRUE`, all primary endpoints must demonstrate equivalence before secondary endpoints are tested.
#' - **Dropout Adjustment**:
#'   - Sample size per arm is adjusted based on the specified dropout rates.
#' - **Randomization and Reproducibility**:
#'   - Uses separate random seeds (`arm_seed_T`, `arm_seed_R`) for treatment and reference arms to ensure reproducibility.
#'
#' @return An `arma::mat` of dimensions `(num_cols x nsim)`, where:
#' - **First row** (`totaly`): Overall equivalence decision (1 = success, 0 = failure).
#' - **Subsequent rows**:
#'   - `E1, E2, ...` (p-values for equivalence testing per endpoint).
#'   - `mu_E1_T`, `mu_E2_T`, ... (mean estimates for the treatment group).
#'   - `mu_E1_R`, `mu_E2_R`, ... (mean estimates for the reference group).
#'   - `sd_E1_T`, `sd_E2_T`, ... (standard deviations for treatment).
#'   - `sd_E1_R`, `sd_E2_R`, ... (standard deviations for reference).
#'
#' @export
run_simulations_par <- function(nsim, n, muT, muR, SigmaT, SigmaR, lequi_tol, uequi_tol, alpha, dropout, typey, adseq, k, arm_seed_T, arm_seed_R, ctype, lognorm, TART, TARR, vareq) {
    .Call(`_SimTOST_run_simulations_par`, nsim, n, muT, muR, SigmaT, SigmaR, lequi_tol, uequi_tol, alpha, dropout, typey, adseq, k, arm_seed_T, arm_seed_R, ctype, lognorm, TART, TARR, vareq)
}

