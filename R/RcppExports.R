# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Compute p-values with Fixed Degrees of Freedom
#'
#' @description
#' Computes the cumulative distribution function (CDF) values (p-values)
#' for a given set of random variables, assuming a t-distribution with fixed
#' degrees of freedom.
#'
#' @param x A numeric matrix (or vector) of random variables.
#' @param df A double specifying the degrees of freedom.
#' @param lower A boolean indicating whether to calculate the lower-tail probability
#' (i.e., P(T <= x)). If `false`, computes the upper-tail probability (P(T > x)).
#'
#' @return A numeric matrix containing the computed CDF values (p-values).
#' @export
ptv <- function(x, df, lower) {
    .Call(`_SimTOST_ptv`, x, df, lower)
}

#' @title Calculate p-values using t-distribution with Variable Degrees of Freedom
#'
#' @description This function computes the cumulative distribution function (p-values) for a given random variable `x`
#' and corresponding degrees of freedom `df` using the t-distribution. The function can compute the lower or upper
#' tail probabilities depending on the value of the `lower` parameter.
#'
#' @param x arma::mat (vector) - A matrix or vector of random variable values for which the p-values will be calculated.
#' @param df arma::mat (vector) - A matrix or vector of degrees of freedom for the t-distribution, matching the size of `x`.
#' @param lower bool - If `TRUE`, calculates the lower-tail probability (P(T <= x)); if `FALSE`, calculates the upper-tail probability.
#' @return arma::mat (vector) - A matrix containing the computed cumulative distribution function (p-values) for each element in `x`.
#' The result is returned as a 1xN matrix, where N is the number of elements in `x`.
#' @export
ptvdf <- function(x, df, lower) {
    .Call(`_SimTOST_ptvdf`, x, df, lower)
}

#' @title Check Equivalence
#'
#' @description
#' This function evaluates whether equivalence criteria are met.
#' It first checks whether all primary endpoints satisfy
#' equivalence (if sequential testing is enabled). Then, it determines whether the
#' required number of endpoints (`k`) meet the equivalence threshold.
#' The function returns a structured matrix that includes equivalence decisions,
#' test results, mean estimates, and standard deviations.
#'
#' @param typey An unsigned integer vector (`arma::uvec`) indicating the type of each endpoint:
#'              - `1` = Primary endpoint
#'              - `2` = Secondary endpoint
#' @param adseq A boolean flag (`TRUE` if sequential testing is enabled).
#'              - If `TRUE`, all primary endpoints must pass equivalence for secondary endpoints to be evaluated.
#'              - If `FALSE`, primary and secondary endpoints are evaluated independently.
#' @param tbioq A matrix (`arma::mat`) indicating the equivalence test results:
#'              - `1` = Equivalence met
#'              - `0` = Equivalence not met
#' @param k An integer specifying the minimum number of endpoints required to establish equivalence.
#' @param mu0 A matrix (`arma::mat`) containing the estimated means for the reference treatment group.
#' @param mu1 A matrix (`arma::mat`) containing the estimated means for the treatment under evaluation.
#' @param sd0 A matrix (`arma::mat`) containing the standard deviations for the reference treatment group.
#' @param sd1 A matrix (`arma::mat`) containing the standard deviations for the treatment under evaluation.
#'
#' @details
#' - **Sequential Adjustment (`adseq = TRUE`)**:
#'   - Ensures that all primary endpoints must meet equivalence before secondary endpoints are evaluated.
#' - **Non-Sequential Testing (`adseq = FALSE`)**:
#'   - Evaluates all endpoints simultaneously without enforcing hierarchical constraints.
#' - **Final Equivalence Decision (`totaly`)**:
#'   - `1` if at least `k` endpoints meet equivalence and (if sequential testing is enabled) all primary endpoints pass.
#'   - `0` otherwise.
#'
#' @return
#' An `arma::mat` containing the final equivalence decision along with test statistics:
#' - `totaly` (1 × 1 matrix): Binary indicator (1 = equivalence established, 0 = not established).
#' - `tbioq` (m × n matrix): Equivalence test results for each endpoint.
#' - `mu0, mu1` (m × n matrices): Mean estimates for the reference and treatment groups.
#' - `sd0, sd1` (m × n matrices): Standard deviations for the reference and treatment groups.
#' @expor
check_equivalence <- function(typey, adseq, tbioq, k, mu0, mu1, sd0, sd1) {
    .Call(`_SimTOST_check_equivalence`, typey, adseq, tbioq, k, mu0, mu1, sd0, sd1)
}

#' @title Simulate a 2x2 Crossover Design and Compute Difference of Means (DOM)
#'
#' @description
#' Simulates a 2x2 crossover design and calculates the p-value for the
#' difference of means (DOM) using a two-sequence, two-period (2x2) study design.
#'
#' @param n integer number of subjects per sequence
#' @param muT vector mean of endpoints on treatment arm
#' @param muR vector mean of endpoints on reference arm
#' @param SigmaW matrix  within subject covar-variance matrix across endpoints
#' @param lequi_tol vector  lower equivalence tolerance band across endpoints
#' @param uequi_tol vector  upper equivalence tolerance band across endpoints
#' @param alpha vector alpha value across endpoints
#' @param sigmaB double between subject variance (assumed same for all endpoints)
#' @param dropout vector of size 2 with dropout proportion per sequence (0,1)
#' @param Eper vector of size 2 with period effect on period (0,1)
#' @param Eco vector of size 2 with carry over effect of arm c(Reference, Treatment).
#' @param typey vector with positions of primary endpoints
#' @param adseq boolean is used a sequential adjustment?
#' @param k integer minimum number of equivalent endpoints
#' @param arm_seed seed for the simulation
#' @return mat(vector) with ptost and other simulated statistics such as mean (mu) and standard deviation(std) per sequence (0,1)-endpoint
#' @export
test_2x2_dom <- function(n, muT, muR, SigmaW, lequi_tol, uequi_tol, alpha, sigmaB, dropout, Eper, Eco, typey, adseq, k, arm_seed) {
    .Call(`_SimTOST_test_2x2_dom`, n, muT, muR, SigmaW, lequi_tol, uequi_tol, alpha, sigmaB, dropout, Eper, Eco, typey, adseq, k, arm_seed)
}

#' @title Simulate a 2x2 Crossover Design and Compute Ratio of Means (ROM)
#'
#' @description
#' Simulates a 2x2 crossover design and calculates the p-value for the
#' ratio of means (ROM) using a two-sequence, two-period (2x2) study design.
#'
#' @param n integer number of subjects per sequence
#' @param muT vector mean of endpoints on treatment arm
#' @param muR vector mean of endpoints on reference arm
#' @param SigmaW matrix  within subject covar-variance matrix across endpoints
#' @param lequi_tol vector  lower equivalence tolerance band across endpoints
#' @param uequi_tol vector  upper equivalence tolerance band across endpoints
#' @param alpha vector alpha value across endpoints
#' @param sigmaB double between subject variance (assumed same for all endpoints)
#' @param dropout vector of size 2 with dropout proportion per sequence (0,1)
#' @param Eper vector of size 2 with period effect on period (0,1)
#' @param Eco vector of size 2 with carry over effect of arm c(Reference, Treatment).
#' @param typey vector with positions of primary endpoints
#' @param adseq boolean is used a sequential adjustment?
#' @param k integer minimum number of equivalent endpoints
#' @param arm_seed seed for the simulation
#' @return mat(vector) with ptost and other simulated statistics such as mean (mu) and standard deviation(std) per sequence (0,1)-endpoint
#' @export
test_2x2_rom <- function(n, muT, muR, SigmaW, lequi_tol, uequi_tol, alpha, sigmaB, dropout, Eper, Eco, typey, adseq, k, arm_seed) {
    .Call(`_SimTOST_test_2x2_rom`, n, muT, muR, SigmaW, lequi_tol, uequi_tol, alpha, sigmaB, dropout, Eper, Eco, typey, adseq, k, arm_seed)
}

#' @title Simulate a Parallel Design and Compute Difference of Means (DOM)
#'
#' @description
#' Simulates a parallel-group design and calculates the p-value for the
#' difference of means (DOM) using an equivalence test.
#'
#' @param n integer number of subjects per arm
#' @param muT vector mean of endpoints on treatment arm
#' @param muR vector mean of endpoints on reference arm
#' @param SigmaT matrix covar-variance matrix on treatment arm across endpoints
#' @param SigmaR matrix covar-variance matrix on reference arm across endpoints
#' @param lequi_tol vector  lower equivalence tolerance band across endpoints
#' @param uequi_tol vector  upper equivalence tolerance band across endpoints
#' @param alpha vector alpha value across endpoints
#' @param dropout vector of size 2 with dropout proportion per arm (T,R)
#' @param typey vector with positions of primary endpoints
#' @param adseq  boolean is used a sequential adjustment?
#' @param k integer minimum number of equivalent endpoints
#' @param arm_seedT integer seed for the simulation on treatment arm
#' @param arm_seedR integer seed for the simulation on reference arm
#' @param TART double treatment allocation rate for the treatment arm
#' @param TARR double treatment allocation rate for the reference arm
#' @param vareq boolean assumed equivalence variance between arms for the t-test
#'
#' @return A numeric matrix containing the following simulated statistics:
#'   - `ptost`: p-values for equivalence testing.
#'   - `mu0`, `mu1`: Mean values for the reference and treatment groups.
#'   - `sd0`, `sd1`: Standard deviations for the reference and treatment groups.
#'   - `totaly`: Indicator (1/0) for equivalence success.
#'
#' @details
#' - The function simulates a parallel-group study design and applies an equivalence test
#'   using the difference of means (DOM) approach.
#' - Adjusts for dropout rates (`dropout`) and treatment allocation rates (`TART`, `TARR`).
#' - Computes test statistics and determines whether the number of significant endpoints meets `k`.
#' - Uses sequential testing if `adseq = TRUE`.
#' - If `vareq = TRUE`, assumes equal variance between treatment and reference groups,
#'   applying Schuirmann’s two one-sided tests (TOST) for equivalence.
#'
#' @export
test_par_dom <- function(n, muT, muR, SigmaT, SigmaR, lequi_tol, uequi_tol, alpha, dropout, typey, adseq, k, arm_seedT, arm_seedR, TART, TARR, vareq) {
    .Call(`_SimTOST_test_par_dom`, n, muT, muR, SigmaT, SigmaR, lequi_tol, uequi_tol, alpha, dropout, typey, adseq, k, arm_seedT, arm_seedR, TART, TARR, vareq)
}

#' @title Simulate a Parallel Design and Compute Ratio of Means (ROM)
#'
#' @description
#' Simulates a parallel-group design and calculates the p-value for the
#' ratio of means (ROM) using an equivalence test.
#'
#' @param n integer number of subjects per arm
#' @param muT vector mean of endpoints on treatment arm
#' @param muR vector mean of endpoints on reference arm
#' @param SigmaT matrix covar-variance matrix on treatment arm across endpoints
#' @param SigmaR matrix covar-variance matrix on reference arm across endpoints
#' @param lequi_tol vector  lower equivalence tolerance band across endpoints
#' @param uequi_tol vector  upper equivalence tolerance band across endpoints
#' @param alpha vector alpha value across endpoints
#' @param dropout vector of size 2 with dropout proportion per arm (T,R)
#' @param typey vector with positions of primary endpoints
#' @param adseq boolean is used a sequential adjustment?
#' @param k integer minimum number of equivalent endpoints
#' @param arm_seedT integer seed for the simulation on treatment arm
#' @param arm_seedR integer seed for the simulation on reference arm
#' @param TART double treatment allocation rate for the treatment arm
#' @param TARR double treatment allocation rate for the reference arm
#' @param vareq Boolean. If `TRUE`, assumes equal variance between arms and applies
#'   Schuirmann’s two one-sided tests (TOST) for equivalence using a pooled variance.
#'
#' @return A numeric matrix containing the following simulated statistics:
#'   - `ptost`: p-values for equivalence testing.
#'   - `mu0`, `mu1`: Mean values for the reference and treatment groups.
#'   - `sd0`, `sd1`: Standard deviations for the reference and treatment groups.
#'   - `totaly`: Indicator (1/0) for equivalence success.
#'
#' @details
#' - The function simulates a parallel-group study design and applies an equivalence test
#'   using the ratio of means (ROM) approach.
#' - Adjusts for dropout rates (`dropout`) and treatment allocation rates (`TART`, `TARR`).
#' - Computes test statistics and determines whether the number of significant endpoints meets `k`.
#' - Uses sequential testing if `adseq = TRUE`.
#' - If `vareq = TRUE`, assumes equal variance between treatment and reference groups,
#'   applying Schuirmann’s two one-sided tests (TOST) for equivalence.
#' @export
test_par_rom <- function(n, muT, muR, SigmaT, SigmaR, lequi_tol, uequi_tol, alpha, dropout, typey, adseq, k, arm_seedT, arm_seedR, TART, TARR, vareq) {
    .Call(`_SimTOST_test_par_rom`, n, muT, muR, SigmaT, SigmaR, lequi_tol, uequi_tol, alpha, dropout, typey, adseq, k, arm_seedT, arm_seedR, TART, TARR, vareq)
}

